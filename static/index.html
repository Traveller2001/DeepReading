<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DeepReading</title>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f8f9fa;
  --sidebar-bg: #ffffff;
  --card-bg: #ffffff;
  --border: #e2e8f0;
  --text: #1a202c;
  --text-secondary: #64748b;
  --primary: #3b82f6;
  --primary-hover: #2563eb;
  --danger: #ef4444;
  --danger-hover: #dc2626;
  --success: #10b981;
  --radius: 8px;
  --shadow: 0 1px 3px rgba(0,0,0,0.08);
  --shadow-lg: 0 4px 16px rgba(0,0,0,0.1);
}

html, body { height: 100%; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Header */
header {
  background: var(--card-bg);
  border-bottom: 1px solid var(--border);
  padding: 12px 24px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
}

header h1 {
  font-size: 20px;
  font-weight: 700;
  color: var(--primary);
}

header .subtitle {
  font-size: 13px;
  color: var(--text-secondary);
}

/* Layout */
.layout {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* Sidebar */
.sidebar {
  width: 300px;
  min-width: 300px;
  background: var(--sidebar-bg);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Upload Zone */
.upload-zone {
  margin: 16px;
  padding: 24px 16px;
  border: 2px dashed var(--border);
  border-radius: var(--radius);
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}

.upload-zone:hover,
.upload-zone.dragover {
  border-color: var(--primary);
  background: rgba(59, 130, 246, 0.04);
}

.upload-zone .icon {
  font-size: 28px;
  margin-bottom: 6px;
  opacity: 0.5;
}

.upload-zone p {
  font-size: 13px;
  color: var(--text-secondary);
}

.upload-zone.uploading {
  opacity: 0.6;
  pointer-events: none;
}

.upload-zone input { display: none; }

/* Search */
.search-box {
  padding: 0 16px;
  flex-shrink: 0;
}

.search-box input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 13px;
  outline: none;
  transition: border-color 0.2s;
}

.search-box input:focus {
  border-color: var(--primary);
}

/* Paper List */
.paper-list {
  flex: 1;
  overflow-y: auto;
  padding: 12px 16px;
}

.paper-item {
  padding: 10px 12px;
  border-radius: var(--radius);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 8px;
  transition: background 0.15s;
  margin-bottom: 4px;
}

.paper-item:hover { background: var(--bg); }
.paper-item.active { background: rgba(59, 130, 246, 0.08); }

.paper-item .info {
  flex: 1;
  min-width: 0;
}

.paper-item .title {
  font-size: 13px;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.paper-item .meta {
  font-size: 11px;
  color: var(--text-secondary);
  margin-top: 2px;
}

.paper-item .badge {
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 10px;
  background: var(--success);
  color: white;
  flex-shrink: 0;
  margin-top: 2px;
}

.paper-item .delete-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  font-size: 14px;
  padding: 2px 4px;
  border-radius: 4px;
  opacity: 0;
  transition: all 0.15s;
  flex-shrink: 0;
}

.paper-item:hover .delete-btn { opacity: 1; }
.paper-item .delete-btn:hover { color: var(--danger); background: rgba(239, 68, 68, 0.08); }

.empty-list {
  text-align: center;
  padding: 32px 16px;
  color: var(--text-secondary);
  font-size: 13px;
}

/* Main Content */
.main {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

/* Welcome */
.welcome {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.welcome .icon { font-size: 48px; opacity: 0.3; margin-bottom: 16px; }
.welcome h2 { font-size: 20px; font-weight: 600; margin-bottom: 8px; }
.welcome p { color: var(--text-secondary); font-size: 14px; }

/* Paper Detail */
#paperView {
  display: none;
  flex: 1;
  flex-direction: column;
  overflow: hidden;
}

.paper-header {
  margin: 24px 32px 0;
  flex-shrink: 0;
}

.paper-header h2 {
  font-size: 22px;
  font-weight: 700;
  line-height: 1.3;
  margin-bottom: 8px;
}

.paper-header .authors {
  color: var(--text-secondary);
  font-size: 14px;
  margin-bottom: 12px;
}

.paper-header .stats {
  display: flex;
  gap: 16px;
  font-size: 12px;
  color: var(--text-secondary);
}

.paper-header .stats span {
  background: var(--bg);
  padding: 4px 10px;
  border-radius: 12px;
}

/* Action Bar */
.action-bar {
  display: flex;
  gap: 10px;
  margin: 16px 32px;
  flex-shrink: 0;
}

.btn {
  padding: 8px 20px;
  border-radius: var(--radius);
  border: none;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.btn-primary {
  background: var(--primary);
  color: white;
}
.btn-primary:hover { background: var(--primary-hover); }
.btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

.btn-secondary {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
}
.btn-secondary:hover { background: var(--border); }

/* Language select */
.lang-select {
  padding: 7px 10px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  font-size: 13px;
  background: var(--card-bg);
  color: var(--text);
  cursor: pointer;
  outline: none;
}
.lang-select:focus { border-color: var(--primary); }

/* Thinking panel (collapsible tool-call log) */
.thinking-panel {
  margin: 0 32px 10px;
  border: 1px solid var(--border);
  border-radius: var(--radius);
  background: var(--bg);
  overflow: hidden;
}

.thinking-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-secondary);
  user-select: none;
  transition: background 0.15s;
}

.thinking-header:hover { background: rgba(0,0,0,0.04); }

.thinking-toggle {
  font-size: 10px;
  transition: transform 0.2s;
  flex-shrink: 0;
}

.thinking-toggle.open { transform: rotate(90deg); }

.thinking-dot {
  width: 6px;
  height: 6px;
  background: var(--primary);
  border-radius: 50%;
  animation: pulse 1.2s infinite;
  flex-shrink: 0;
}

.thinking-badge {
  font-size: 11px;
  background: rgba(59, 130, 246, 0.1);
  color: var(--primary);
  padding: 1px 6px;
  border-radius: 10px;
  flex-shrink: 0;
  margin-left: auto;
}

.thinking-body {
  padding: 4px 12px 8px;
  font-size: 12px;
  color: var(--text-secondary);
  max-height: 200px;
  overflow-y: auto;
  border-top: 1px solid var(--border);
  line-height: 1.6;
}

.thinking-item {
  padding: 2px 0;
  display: flex;
  align-items: baseline;
  gap: 6px;
}

.thinking-item::before {
  content: '\25b8';
  color: var(--primary);
  opacity: 0.5;
  flex-shrink: 0;
  font-size: 10px;
}

@keyframes pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1; }
}

/* Split layout */
.main-split {
  display: flex;
  flex: 1;
  overflow: hidden;
  gap: 0;
}

.main-split .report-side {
  flex: 1;
  overflow-y: auto;
  padding: 0 32px 32px;
  min-width: 0;
}

/* Report Content */
.report-content {
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 32px;
  box-shadow: var(--shadow);
  line-height: 1.7;
}

.report-content h2 {
  font-size: 20px;
  font-weight: 700;
  margin: 28px 0 12px;
  padding-bottom: 6px;
  border-bottom: 2px solid var(--primary);
  color: var(--primary);
}

.report-content h2:first-child { margin-top: 0; }

.report-content h3 {
  font-size: 16px;
  font-weight: 600;
  margin: 20px 0 8px;
}

.report-content p { margin-bottom: 12px; font-size: 14.5px; }

.report-content ul, .report-content ol {
  margin: 8px 0 16px 24px;
  font-size: 14.5px;
}

.report-content li { margin-bottom: 4px; }

.report-content img {
  max-width: 100%;
  height: auto;
  border-radius: var(--radius);
  margin: 16px auto;
  display: block;
  box-shadow: var(--shadow-lg);
  border: 1px solid var(--border);
}

.report-content code {
  background: var(--bg);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
}

.report-content .mermaid-container {
  text-align: center;
  margin: 24px 0;
  padding: 24px 16px;
  background: linear-gradient(135deg, #f8fafc 0%, #f0f4f8 100%);
  border-radius: 12px;
  border: 1px solid #e2e8f0;
  overflow-x: auto;
  box-shadow: 0 1px 3px rgba(0,0,0,0.04);
}

.report-content .mermaid-container svg {
  max-width: 100%;
  height: auto;
  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.06));
}

.report-content blockquote {
  border-left: 3px solid var(--primary);
  padding-left: 16px;
  margin: 12px 0;
  color: var(--text-secondary);
}

.report-content strong { font-weight: 600; }

/* PDF Panel */
.pdf-panel {
  width: 50%;
  min-width: 320px;
  border-left: 2px solid var(--border);
  display: none;
  flex-direction: column;
  background: var(--card-bg);
  flex-shrink: 0;
  overflow: hidden;
}

.pdf-panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 14px;
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  font-size: 13px;
  font-weight: 600;
  flex-shrink: 0;
}

.pdf-panel-header button {
  background: none;
  border: none;
  font-size: 18px;
  cursor: pointer;
  color: var(--text-secondary);
  padding: 2px 6px;
  border-radius: 4px;
  line-height: 1;
}

.pdf-panel-header button:hover {
  background: var(--border);
  color: var(--text);
}

/* PDF toggle button */
.btn-pdf {
  background: var(--bg);
  color: var(--primary);
  border: 1px solid var(--primary);
}
.btn-pdf:hover {
  background: rgba(59, 130, 246, 0.08);
}

/* Citation badge */
.citation {
  display: inline-flex;
  align-items: center;
  font-size: 11px;
  font-weight: 600;
  color: var(--primary);
  background: rgba(59, 130, 246, 0.08);
  border: 1px solid rgba(59, 130, 246, 0.2);
  padding: 1px 6px;
  border-radius: 10px;
  cursor: pointer;
  margin-left: 2px;
  vertical-align: middle;
  transition: all 0.15s;
  text-decoration: none;
  line-height: 1.5;
}

.citation:hover {
  background: rgba(59, 130, 246, 0.18);
  border-color: var(--primary);
  color: var(--primary-hover);
}

/* PDF Viewer (pdf.js) */
.pdf-viewer-container {
  flex: 1;
  overflow-y: auto;
  background: #525659;
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.pdf-page-wrapper {
  position: relative;
  background: white;
  box-shadow: 0 1px 4px rgba(0,0,0,0.3);
  flex-shrink: 0;
  overflow: hidden;
}

.pdf-page-wrapper canvas {
  display: block;
}

.pdf-page-label {
  position: absolute;
  bottom: 4px;
  right: 6px;
  font-size: 10px;
  color: rgba(0,0,0,0.35);
  background: rgba(255,255,255,0.7);
  padding: 1px 5px;
  border-radius: 3px;
  pointer-events: none;
}

.page-highlight-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 2;
  animation: highlightFadeOut 2.5s ease-out forwards;
  border: 3px solid rgba(59,130,246,0.8);
  background: rgba(59,130,246,0.15);
}

@keyframes highlightFadeOut {
  0% { border-color: rgba(59,130,246,0.9); background: rgba(59,130,246,0.25); }
  60% { border-color: rgba(59,130,246,0.4); background: rgba(59,130,246,0.06); }
  100% { border-color: transparent; background: transparent; }
}

/* Text-level highlight (computed rectangles) */
.pdf-highlight-layer {
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 3;
}

.pdf-highlight-rect {
  position: absolute;
  background: rgba(255, 212, 0, 0.45);
  border-radius: 2px;
  pointer-events: none;
}

/* Spinner */
.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid var(--border);
  border-top-color: var(--primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* Toast */
.toast {
  position: fixed;
  bottom: 24px;
  right: 24px;
  padding: 12px 20px;
  background: var(--text);
  color: white;
  border-radius: var(--radius);
  font-size: 13px;
  box-shadow: var(--shadow-lg);
  z-index: 1000;
  animation: slideUp 0.3s;
}

@keyframes slideUp {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.toast.error { background: var(--danger); }

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-secondary); }

/* Discussion Feature */

.panel-tabs {
  display: flex;
  gap: 0;
  flex: 1;
}

.panel-tab {
  padding: 6px 16px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  border: none;
  background: none;
  color: var(--text-secondary);
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
}

.panel-tab:hover { color: var(--text); }
.panel-tab.active {
  color: var(--primary);
  border-bottom-color: var(--primary);
}

.discussion-view {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: none;
  flex-direction: column;
  gap: 12px;
}

.discussion-view.active { display: flex; }

.discussion-round-divider {
  text-align: center;
  font-size: 12px;
  font-weight: 600;
  color: var(--text-secondary);
  padding: 8px 0;
  display: flex;
  align-items: center;
  gap: 12px;
}

.discussion-round-divider::before,
.discussion-round-divider::after {
  content: '';
  flex: 1;
  height: 1px;
  background: var(--border);
}

.discussion-msg {
  padding: 12px 16px;
  border-radius: var(--radius);
  font-size: 13.5px;
  line-height: 1.65;
  border-left: 3px solid;
  word-wrap: break-word;
}

.discussion-msg .msg-label {
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 6px;
}

.discussion-msg.reader {
  background: rgba(59, 130, 246, 0.06);
  border-left-color: var(--primary);
}

.discussion-msg.reader .msg-label { color: var(--primary); }

.discussion-msg.writer {
  background: rgba(16, 185, 129, 0.06);
  border-left-color: var(--success);
}

.discussion-msg.writer .msg-label { color: var(--success); }

.discussion-msg .msg-body { white-space: pre-wrap; }
.discussion-msg .msg-body.rendered { white-space: normal; }
.discussion-msg .msg-body p { margin-bottom: 8px; font-size: 13.5px; }
.discussion-msg .msg-body p:last-child { margin-bottom: 0; }
.discussion-msg .msg-body code {
  background: rgba(0,0,0,0.06);
  padding: 1px 4px;
  border-radius: 3px;
  font-size: 12.5px;
}
.discussion-msg .msg-body .citation { font-size: 10px; }

.polish-indicator {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 16px;
  margin: 0 32px 10px;
  background: linear-gradient(90deg, rgba(16,185,129,0.08), rgba(59,130,246,0.08));
  border-radius: var(--radius);
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  border: 1px solid var(--border);
}

.polish-indicator .spinner {
  border-top-color: var(--success);
}

.discussion-empty {
  text-align: center;
  padding: 32px 16px;
  color: var(--text-secondary);
  font-size: 13px;
}
</style>
</head>
<body>

<header>
  <h1>DeepReading</h1>
  <span class="subtitle">AI-powered paper reading assistant</span>
</header>

<div class="layout">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="upload-zone" id="uploadZone">
      <div class="icon">+</div>
      <p>üìé Drop PDF here or click to upload</p>
      <input type="file" id="fileInput" accept=".pdf">
    </div>

    <div class="search-box">
      <input type="text" id="searchInput" placeholder="Search papers...">
    </div>

    <div class="paper-list" id="paperList">
      <div class="empty-list">No papers yet. Upload a PDF to get started.</div>
    </div>
  </aside>

  <!-- Main -->
  <main class="main" id="mainContent">
    <div class="welcome" id="welcomeView">
      <div>
        <div class="icon">&#128218;</div>
        <h2>Welcome to DeepReading</h2>
        <p>Upload a PDF paper to generate a structured reading report<br>with extracted figures and AI-powered analysis.</p>
      </div>
    </div>

    <div id="paperView">
      <div class="paper-header" id="paperHeader"></div>
      <div class="action-bar" id="actionBar"></div>
      <div class="thinking-panel" id="thinkingPanel" style="display:none;">
        <div class="thinking-header" onclick="toggleThinking()">
          <span class="thinking-toggle" id="thinkingToggle">&#9654;</span>
          <span class="thinking-dot" id="thinkingDot"></span>
          <span id="thinkingTitle">Analyzing paper...</span>
          <span class="thinking-badge" id="thinkingBadge" style="display:none;"></span>
        </div>
        <div class="thinking-body" id="thinkingBody" style="display:none;"></div>
      </div>
      <div class="main-split" id="mainSplit">
        <div class="report-side" id="reportSide">
          <div class="report-content" id="reportContent" style="display:none;"></div>
        </div>
        <div class="pdf-panel" id="pdfPanel">
          <div class="pdf-panel-header">
            <div class="panel-tabs">
              <button class="panel-tab active" id="tabPdf" onclick="switchPanelTab('pdf')">üìÑ PDF</button>
              <button class="panel-tab" id="tabDiscussion" onclick="switchPanelTab('discussion')">üí¨ Discussion</button>
            </div>
            <button onclick="closeRightPanel()" title="Close panel">&times;</button>
          </div>
          <div id="pdfViewerContainer" class="pdf-viewer-container"></div>
          <div id="discussionView" class="discussion-view">
            <div class="discussion-empty">Discussion will start automatically after report generation.</div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
const $ = (sel) => document.querySelector(sel);
const API = '/api';

let currentPaperId = null;
let isGenerating = false;
let isDiscussing = false;
let eventSource = null;

// --- Upload ---
const uploadZone = $('#uploadZone');
const fileInput = $('#fileInput');

uploadZone.addEventListener('click', () => fileInput.click());
uploadZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  uploadZone.classList.add('dragover');
});
uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
uploadZone.addEventListener('drop', (e) => {
  e.preventDefault();
  uploadZone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (file && file.name.toLowerCase().endsWith('.pdf')) uploadFile(file);
  else showToast('Please drop a PDF file', true);
});
fileInput.addEventListener('change', () => {
  if (fileInput.files[0]) uploadFile(fileInput.files[0]);
});

async function uploadFile(file) {
  uploadZone.classList.add('uploading');
  uploadZone.querySelector('p').textContent = 'Processing...';
  const formData = new FormData();
  formData.append('file', file);
  try {
    const res = await fetch(`${API}/papers/upload`, { method: 'POST', body: formData });
    if (!res.ok) throw new Error((await res.json()).detail || 'Upload failed');
    const data = await res.json();
    showToast(`Uploaded: ${data.title} (${data.num_figures} figures)`);
    await loadPaperList();
    selectPaper(data.paper_id);
  } catch (e) {
    showToast(e.message, true);
  } finally {
    uploadZone.classList.remove('uploading');
    uploadZone.querySelector('p').textContent = 'üìé Drop PDF here or click to upload';
    fileInput.value = '';
  }
}

// --- Paper List ---
let searchTimer = null;
$('#searchInput').addEventListener('input', (e) => {
  clearTimeout(searchTimer);
  searchTimer = setTimeout(() => loadPaperList(e.target.value), 300);
});

async function loadPaperList(query = '') {
  try {
    const res = await fetch(`${API}/papers?q=${encodeURIComponent(query)}`);
    const papers = await res.json();
    renderPaperList(papers);
  } catch (e) {
    console.error('Failed to load papers:', e);
  }
}

function renderPaperList(papers) {
  const list = $('#paperList');
  if (!papers.length) {
    list.innerHTML = '<div class="empty-list">No papers found.</div>';
    return;
  }
  list.innerHTML = papers.map(p => `
    <div class="paper-item ${p.id === currentPaperId ? 'active' : ''}"
         data-id="${p.id}" onclick="selectPaper('${p.id}')">
      <div class="info">
        <div class="title">${escapeHtml(p.title || p.filename)}</div>
        <div class="meta">${p.num_pages} pages &middot; ${p.num_figures} figures &middot; ${formatDate(p.created_at)}</div>
      </div>
      ${p.has_report ? '<span class="badge">Report</span>' : ''}
      <button class="delete-btn" onclick="event.stopPropagation(); deletePaper('${p.id}')" title="Delete">&times;</button>
    </div>
  `).join('');
}

async function deletePaper(id) {
  if (!confirm('Delete this paper and its report?')) return;
  try {
    await fetch(`${API}/papers/${id}`, { method: 'DELETE' });
    if (currentPaperId === id) {
      currentPaperId = null;
      showWelcome();
    }
    await loadPaperList($('#searchInput').value);
    showToast('Paper deleted');
  } catch (e) {
    showToast('Failed to delete', true);
  }
}

// --- Paper Detail ---
async function selectPaper(id) {
  if (isGenerating && eventSource) {
    eventSource.close();
    isGenerating = false;
  }
  if (isDiscussing) {
    isDiscussing = false;
  }
  currentPaperId = id;
  document.querySelectorAll('.paper-item').forEach(el => {
    el.classList.toggle('active', el.dataset.id === id);
  });

  try {
    const res = await fetch(`${API}/papers/${id}`);
    const paper = await res.json();
    showPaperView(paper);
  } catch (e) {
    showToast('Failed to load paper', true);
  }
}

function showWelcome() {
  $('#welcomeView').style.display = 'flex';
  $('#paperView').style.display = 'none';
}

function showPaperView(paper) {
  $('#welcomeView').style.display = 'none';
  $('#paperView').style.display = 'flex';

  // Header
  $('#paperHeader').innerHTML = `
    <h2>${escapeHtml(paper.title)}</h2>
    ${paper.authors ? `<div class="authors">${escapeHtml(paper.authors)}</div>` : ''}
    <div class="stats">
      <span>${paper.num_pages} pages</span>
      <span>${paper.num_figures} figures</span>
      <span>${escapeHtml(paper.filename)}</span>
    </div>
  `;

  // Actions
  const hasReport = !!paper.report;
  $('#actionBar').innerHTML = `
    <button class="btn btn-primary" id="btnGenerate" onclick="generateReport('${paper.id}')"
            ${isGenerating || isDiscussing ? 'disabled' : ''}>
      ${hasReport ? 'üîÑ Regenerate Report' : '‚ú® Generate Report'}
    </button>
    <select id="langSelect" class="lang-select">
      <option value="en">English</option>
      <option value="zh">‰∏≠Êñá</option>
    </select>
    <button class="btn btn-pdf" onclick="openPdfPanel()">üìÑ View PDF</button>
    ${hasReport ? `<a class="btn btn-secondary btn-download" href="${API}/papers/${paper.id}/report" download>‚¨á Download .md</a>` : ''}
  `;

  // Report
  const rc = $('#reportContent');
  const tp = $('#thinkingPanel');
  tp.style.display = 'none';
  closeRightPanel();
  if (hasReport) {
    rc.style.display = 'block';
    rc.innerHTML = renderMarkdown(paper.report);
    renderMermaidDiagrams();
    // Load saved discussion
    loadSavedDiscussion(paper.id);
  } else {
    rc.style.display = 'none';
    rc.innerHTML = '';
    // Reset discussion view
    $('#discussionView').innerHTML = '<div class="discussion-empty">Discussion will start automatically after report generation.</div>';
  }
}

// --- Report Generation (SSE) with integrated Discussion ---
function generateReport(paperId) {
  if (isGenerating) return;
  isGenerating = true;

  const rc = $('#reportContent');
  const tp = $('#thinkingPanel');
  rc.style.display = 'block';
  rc.innerHTML = '';
  tp.style.display = 'block';
  resetThinking();

  const btn = $('#actionBar .btn-primary');
  if (btn) { btn.disabled = true; btn.textContent = '‚è≥ Generating...'; }

  let markdown = '';
  let renderTimer = null;
  const lang = ($('#langSelect') || {}).value || 'en';

  // Discussion state (used when discussion events arrive in the same stream)
  let inDiscussion = false;
  let currentMsgEl = null;
  let polishIndicator = null;
  let polishMarkdown = '';
  let polishRenderTimer = null;
  const discView = $('#discussionView');

  eventSource = new EventSource(`${API}/papers/${paperId}/generate?lang=${lang}`);

  eventSource.onmessage = (e) => {
    if (e.data === '[DONE]') {
      eventSource.close();
      isGenerating = false;
      isDiscussing = false;

      // Finalize thinking panel
      $('#thinkingDot').style.display = 'none';
      $('#thinkingTitle').textContent = `Analysis complete (${thinkingSteps.length} tool calls)`;
      $('#thinkingToggle').classList.remove('open');
      $('#thinkingBody').style.display = 'none';

      if (!inDiscussion) {
        // No discussion happened (e.g. empty report), finalize report only
        const replaceMatch = markdown.match(/<!--FULL_REPLACE-->([\s\S]*)<!--\/FULL_REPLACE-->/);
        const finalMarkdown = replaceMatch ? replaceMatch[1] : markdown;
        rc.innerHTML = renderMarkdown(finalMarkdown);
        renderMermaidDiagrams();
      }

      if (polishIndicator) polishIndicator.remove();
      if (btn) { btn.disabled = false; btn.textContent = 'üîÑ Regenerate Report'; }

      if (!$('#actionBar .btn-download')) {
        const dl = document.createElement('a');
        dl.className = 'btn btn-secondary btn-download';
        dl.href = `${API}/papers/${paperId}/report`;
        dl.download = '';
        dl.textContent = '‚¨á Download .md';
        $('#actionBar').appendChild(dl);
      }

      loadPaperList($('#searchInput').value);
      return;
    }

    let parsed;
    try {
      parsed = JSON.parse(e.data);
    } catch {
      if (!inDiscussion) markdown += e.data;
      return;
    }

    // Error handling
    if (parsed && typeof parsed === 'object' && parsed.error) {
      eventSource.close();
      isGenerating = false;
      isDiscussing = false;
      $('#thinkingPanel').style.display = 'none';
      if (btn) { btn.disabled = false; btn.textContent = '‚ú® Generate Report'; }
      showToast('Error: ' + parsed.error, true);
      return;
    }

    // Discussion/polish events (dict with type field)
    if (parsed && typeof parsed === 'object' && parsed.type) {
      handleDiscussionEvent(parsed, discView, rc);
      return;
    }

    // Report text chunk (string)
    const text = typeof parsed === 'string' ? parsed : String(parsed);

    // Detect status messages
    const statusMatch = text.match(/<!--STATUS:(.*?)-->/);
    if (statusMatch) {
      addThinkingStep(statusMatch[1]);
      const cleaned = text.replace(/<!--STATUS:.*?-->/g, '');
      if (cleaned) markdown += cleaned;
    } else {
      markdown += text;
    }

    if (!renderTimer) {
      renderTimer = requestAnimationFrame(() => {
        rc.innerHTML = renderMarkdown(markdown);
        renderTimer = null;
      });
    }
  };

  eventSource.onerror = () => {
    // Don't kill connection if we have data ‚Äî SSE may recover on its own.
    // Only close if we never received anything (true connection failure).
    if (!markdown && !inDiscussion) {
      eventSource.close();
      isGenerating = false;
      isDiscussing = false;
      $('#thinkingDot').style.display = 'none';
      $('#thinkingTitle').textContent = 'Generation interrupted';
      if (btn) { btn.disabled = false; btn.textContent = '‚ú® Generate Report'; }
      if (polishIndicator) polishIndicator.remove();
      showToast('Connection lost. Please try again.', true);
    }
  };

  // --- Inline handler for discussion events within the same stream ---
  function handleDiscussionEvent(event, discView, rc) {
    switch (event.type) {
      case 'discussion_start': {
        inDiscussion = true;
        isDiscussing = true;
        // Finalize report rendering before starting discussion
        const replaceMatch = markdown.match(/<!--FULL_REPLACE-->([\s\S]*)<!--\/FULL_REPLACE-->/);
        const finalMarkdown = replaceMatch ? replaceMatch[1] : markdown;
        rc.innerHTML = renderMarkdown(finalMarkdown);
        renderMermaidDiagrams();

        // Collapse thinking panel
        $('#thinkingDot').style.display = 'none';
        $('#thinkingTitle').textContent = `Report done (${thinkingSteps.length} tool calls). Starting review...`;
        $('#thinkingToggle').classList.remove('open');
        $('#thinkingBody').style.display = 'none';

        // Open right panel with Discussion tab
        const panel = $('#pdfPanel');
        panel.style.display = 'flex';
        switchPanelTab('discussion');
        discView.innerHTML = '';

        if (btn) btn.textContent = 'üí¨ Reviewing...';
        break;
      }
      case 'discussion_round': {
        // Render previous writer message if there was one
        if (currentMsgEl && currentMsgEl.classList.contains('writer')) {
          renderDiscussionMsgBody(currentMsgEl.querySelector('.msg-body'));
        }
        const divider = document.createElement('div');
        divider.className = 'discussion-round-divider';
        divider.textContent = `Round ${event.round} / ${event.total}`;
        discView.appendChild(divider);
        currentMsgEl = null;
        break;
      }
      case 'reader_chunk': {
        if (!currentMsgEl || !currentMsgEl.classList.contains('reader') || parseInt(currentMsgEl.dataset.round) !== event.round) {
          currentMsgEl = createDiscussionMsg('reader', event.round);
          currentMsgEl.dataset.round = event.round;
          discView.appendChild(currentMsgEl);
        }
        const rbody = currentMsgEl.querySelector('.msg-body');
        rbody.dataset.raw = (rbody.dataset.raw || '') + event.content;
        rbody.textContent = rbody.dataset.raw;
        discView.scrollTop = discView.scrollHeight;
        break;
      }
      case 'writer_chunk': {
        if (!currentMsgEl || !currentMsgEl.classList.contains('writer') || parseInt(currentMsgEl.dataset.round) !== event.round) {
          currentMsgEl = createDiscussionMsg('writer', event.round);
          currentMsgEl.dataset.round = event.round;
          discView.appendChild(currentMsgEl);
        }
        const wbody = currentMsgEl.querySelector('.msg-body');
        // Accumulate raw text properly in dataset
        wbody.dataset.raw = (wbody.dataset.raw || '') + event.content;
        // Show plain text during streaming to avoid rendering thrash
        wbody.textContent = wbody.dataset.raw;
        discView.scrollTop = discView.scrollHeight;
        break;
      }
      case 'discussion_end': {
        // Final render pass: render all messages with markdown/citations/LaTeX
        discView.querySelectorAll('.discussion-msg .msg-body').forEach(renderDiscussionMsgBody);
        if (btn) btn.textContent = '‚úèÔ∏è Polishing...';
        break;
      }
      case 'polish_start': {
        polishIndicator = document.createElement('div');
        polishIndicator.className = 'polish-indicator';
        polishIndicator.innerHTML = '<span class="spinner"></span> Polishing report based on discussion...';
        const reportSide = $('#reportSide');
        reportSide.insertBefore(polishIndicator, reportSide.firstChild);
        // Reset polish accumulator for streaming
        polishMarkdown = '';
        polishRenderTimer = null;
        break;
      }
      case 'polish_chunk': {
        polishMarkdown += event.content;
        if (!polishRenderTimer) {
          polishRenderTimer = requestAnimationFrame(() => {
            rc.innerHTML = renderMarkdown(polishMarkdown);
            polishRenderTimer = null;
          });
        }
        break;
      }
      case 'polish_end': {
        if (polishIndicator) polishIndicator.remove();
        polishIndicator = null;
        // Final render with the complete polished report
        const finalReport = event.report || polishMarkdown;
        if (finalReport) {
          rc.innerHTML = renderMarkdown(finalReport);
          renderMermaidDiagrams();
        }
        break;
      }
      case 'discussion_error': {
        showToast('Discussion error: ' + (event.error || 'Unknown'), true);
        break;
      }
    }
  }
}

// --- Render markdown with citations (placeholder approach) ---
// Citations are extracted BEFORE marked.parse to avoid bracket interference.
function renderMarkdown(rawMarkdown) {
  // Strip status markers
  let md = rawMarkdown.replace(/<!--STATUS:.*?-->/g, '');

  // Only show content from first heading onward (skip LLM thinking text)
  const headingIdx = md.search(/^##\s/m);
  if (headingIdx > 0) md = md.substring(headingIdx);

  // Extract citations ‚Üí placeholders before markdown parsing
  const cites = [];
  md = md.replace(
    /\[\[p\.(\d+)(?::(\d+))?\s*(?:"([^"]*)")?\s*\]\]/g,
    (match, page, yPos, quote) => {
      cites.push({ page, yPos: yPos || null, quote: quote || '' });
      return `%%CITE${cites.length - 1}%%`;
    }
  );

  // Parse markdown (preserves %%CITE_N%% as plain text)
  let html = marked.parse(md);

  // Replace placeholders with citation badges
  html = html.replace(/%%CITE(\d+)%%/g, (m, idx) => {
    const c = cites[parseInt(idx)];
    if (!c) return m;
    const yAttr = c.yPos ? ` data-y="${c.yPos}"` : '';
    const qSafe = c.quote.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
    const quoteAttr = c.quote ? ` data-quote="${qSafe}"` : '';
    return `<span class="citation" data-page="${c.page}"${yAttr}${quoteAttr}>[p.${c.page}]</span>`;
  });

  // Convert mermaid code blocks to renderable containers
  html = html.replace(
    /<pre><code class="language-mermaid">([\s\S]*?)<\/code><\/pre>/g,
    (match, code) => {
      const decoded = code
        .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&').replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
      return `<div class="mermaid-container"><pre class="mermaid">${decoded}</pre></div>`;
    }
  );

  return html;
}

// Render mermaid diagrams after DOM update
let _mermaidId = 0;
async function renderMermaidDiagrams() {
  const nodes = document.querySelectorAll('#reportContent pre.mermaid');
  for (const node of nodes) {
    if (node.dataset.rendered) continue;
    node.dataset.rendered = 'true';
    try {
      const id = 'mermaid-' + (++_mermaidId);
      const { svg } = await mermaid.render(id, node.textContent.trim());
      node.innerHTML = svg;
    } catch (e) {
      console.warn('Mermaid render error:', e);
      // Leave the raw code visible on error
      node.style.color = 'var(--text-secondary)';
      node.style.fontSize = '12px';
    }
  }
}

// --- Thinking panel ---
let thinkingSteps = [];

function toggleThinking() {
  const body = $('#thinkingBody');
  const toggle = $('#thinkingToggle');
  const isHidden = body.style.display === 'none';
  body.style.display = isHidden ? 'block' : 'none';
  toggle.classList.toggle('open', isHidden);
}

function addThinkingStep(text) {
  thinkingSteps.push(text);
  const body = $('#thinkingBody');
  const item = document.createElement('div');
  item.className = 'thinking-item';
  item.textContent = text;
  body.appendChild(item);
  body.scrollTop = body.scrollHeight;
  const badge = $('#thinkingBadge');
  badge.style.display = 'inline';
  badge.textContent = thinkingSteps.length + ' steps';
  $('#thinkingTitle').textContent = text;
}

function resetThinking() {
  thinkingSteps = [];
  $('#thinkingBody').innerHTML = '';
  $('#thinkingBadge').style.display = 'none';
  $('#thinkingTitle').textContent = 'Analyzing paper...';
  $('#thinkingToggle').classList.remove('open');
  $('#thinkingBody').style.display = 'none';
  $('#thinkingDot').style.display = '';
}

// Event delegation for citation clicks
document.getElementById('reportContent').addEventListener('click', (e) => {
  const cite = e.target.closest('.citation');
  if (!cite) return;
  const page = parseInt(cite.dataset.page);
  const y = cite.dataset.y ? parseInt(cite.dataset.y) : null;
  const quote = cite.dataset.quote || '';
  goToPage(page, quote, y);
});

// Citation clicks in discussion panel
document.getElementById('discussionView').addEventListener('click', (e) => {
  const cite = e.target.closest('.citation');
  if (!cite) return;
  const page = parseInt(cite.dataset.page);
  const y = cite.dataset.y ? parseInt(cite.dataset.y) : null;
  const quote = cite.dataset.quote || '';
  // Switch to PDF tab and navigate
  switchPanelTab('pdf');
  goToPage(page, quote, y);
});

// --- PDF Viewer (pdf.js) ---
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

const pdfState = {
  doc: null,
  paperId: null,
  pageInfos: [],
  rendered: new Set(),
  observer: null,
};

async function loadPdfDocument(paperId) {
  const container = $('#pdfViewerContainer');
  container.innerHTML = '<div style="color:#aaa;text-align:center;padding:40px;">Loading PDF...</div>';

  try {
    const doc = await pdfjsLib.getDocument(`/data/uploads/${paperId}.pdf`).promise;
    pdfState.doc = doc;
    pdfState.paperId = paperId;
    pdfState.rendered.clear();
    pdfState.pageInfos = [];

    // Get page dimensions for correctly-sized placeholders
    const containerWidth = container.clientWidth - 16;
    for (let i = 1; i <= doc.numPages; i++) {
      const page = await doc.getPage(i);
      const vp = page.getViewport({ scale: 1 });
      const scale = Math.max(containerWidth / vp.width, 0.5);
      pdfState.pageInfos.push({ width: vp.width * scale, height: vp.height * scale, scale });
    }

    // Create page placeholder elements
    container.innerHTML = '';
    for (let i = 0; i < doc.numPages; i++) {
      const info = pdfState.pageInfos[i];
      const wrapper = document.createElement('div');
      wrapper.className = 'pdf-page-wrapper';
      wrapper.id = `pdfPage${i + 1}`;
      wrapper.dataset.page = i + 1;
      wrapper.style.width = info.width + 'px';
      wrapper.style.height = info.height + 'px';

      const label = document.createElement('div');
      label.className = 'pdf-page-label';
      label.textContent = i + 1;
      wrapper.appendChild(label);
      container.appendChild(wrapper);
    }

    // Lazy render pages as they scroll into view
    if (pdfState.observer) pdfState.observer.disconnect();
    pdfState.observer = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.isIntersecting) renderPdfPage(parseInt(e.target.dataset.page));
      });
    }, { root: container, rootMargin: '600px 0px' });
    container.querySelectorAll('.pdf-page-wrapper').forEach(el => pdfState.observer.observe(el));

  } catch (e) {
    container.innerHTML = '<div style="color:#f66;text-align:center;padding:40px;">Failed to load PDF</div>';
    console.error('PDF load error:', e);
  }
}

async function renderPdfPage(pageNum) {
  if (pdfState.rendered.has(pageNum) || !pdfState.doc) return;
  pdfState.rendered.add(pageNum);

  const page = await pdfState.doc.getPage(pageNum);
  const info = pdfState.pageInfos[pageNum - 1];
  const viewport = page.getViewport({ scale: info.scale });
  const dpr = window.devicePixelRatio || 1;

  const canvas = document.createElement('canvas');
  canvas.width = Math.floor(viewport.width * dpr);
  canvas.height = Math.floor(viewport.height * dpr);
  canvas.style.width = viewport.width + 'px';
  canvas.style.height = viewport.height + 'px';

  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  await page.render({ canvasContext: ctx, viewport }).promise;

  const wrapper = document.getElementById(`pdfPage${pageNum}`);
  if (wrapper) wrapper.insertBefore(canvas, wrapper.firstChild);
}

async function goToPage(page, quote, yNorm) {
  const panel = $('#pdfPanel');
  panel.style.display = 'flex';
  panel.offsetHeight; // force reflow so container has width
  switchPanelTab('pdf');

  if (pdfState.paperId !== currentPaperId) {
    await loadPdfDocument(currentPaperId);
  }

  // Ensure the target page is rendered before scrolling
  await renderPdfPage(page);

  const wrapper = document.getElementById(`pdfPage${page}`);
  if (!wrapper) return;

  // Remove any previous highlights
  document.querySelectorAll('.page-highlight-overlay, .pdf-highlight-layer').forEach(el => el.remove());

  // Try text-level highlight if quote is available
  let textHighlighted = false;
  if (quote) {
    textHighlighted = await highlightQuoteOnPage(page, quote);
  }

  // Fallback: use y-position or page-level highlight
  if (!textHighlighted) {
    if (yNorm !== null && yNorm !== undefined) {
      scrollToYPosition(wrapper, yNorm);
    } else {
      const overlay = document.createElement('div');
      overlay.className = 'page-highlight-overlay';
      wrapper.appendChild(overlay);
      overlay.addEventListener('animationend', () => overlay.remove());
      wrapper.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }
}

function scrollToYPosition(wrapper, yNorm) {
  const container = $('#pdfViewerContainer');
  const wrapperRect = wrapper.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  const pageHeight = wrapperRect.height;

  // yNorm is 0-1000, convert to pixel offset within the page
  const yPixel = (yNorm / 1000) * pageHeight;

  // Calculate the absolute scroll position in the container
  const wrapperTopInContainer = container.scrollTop + wrapperRect.top - containerRect.top;
  const targetScroll = wrapperTopInContainer + yPixel - containerRect.height / 3;

  container.scrollTo({ top: targetScroll, behavior: 'smooth' });

  // Add a brief position indicator line
  const indicator = document.createElement('div');
  indicator.style.cssText = `
    position: absolute;
    left: 0; right: 0;
    top: ${yPixel}px;
    height: 3px;
    background: rgba(59, 130, 246, 0.6);
    z-index: 5;
    pointer-events: none;
    animation: highlightFadeOut 2.5s ease-out forwards;
  `;
  wrapper.appendChild(indicator);
  indicator.addEventListener('animationend', () => indicator.remove());
}

async function highlightQuoteOnPage(pageNum, quote) {
  if (!pdfState.doc || !quote) return false;
  const wrapper = document.getElementById(`pdfPage${pageNum}`);
  if (!wrapper) return false;

  try {
    const page = await pdfState.doc.getPage(pageNum);
    const info = pdfState.pageInfos[pageNum - 1];
    const viewport = page.getViewport({ scale: info.scale });
    const textContent = await page.getTextContent();

    // Build searchable text from text content items (with geometry)
    let fullText = '';
    const itemMap = [];
    for (const item of textContent.items) {
      const str = item.str || '';
      if (!str) continue;
      itemMap.push({
        start: fullText.length,
        end: fullText.length + str.length,
        item: item,
      });
      fullText += str + ' ';
    }

    // Search with multiple strategies
    const searchText = quote.trim().toLowerCase();
    const fullLower = fullText.toLowerCase();
    let matchStart = -1, matchLen = searchText.length;

    // Strategy 1: exact substring match
    matchStart = fullLower.indexOf(searchText);

    // Strategy 2: flexible whitespace (join words with \s+)
    if (matchStart === -1) {
      const words = searchText.split(/\s+/).filter(w => w.length > 0);
      if (words.length >= 2) {
        const pattern = words.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('\\s+');
        const regex = new RegExp(pattern, 'i');
        const m = fullText.match(regex);
        if (m) { matchStart = m.index; matchLen = m[0].length; }
      }
    }

    // Strategy 3: partial match with first half of words
    if (matchStart === -1) {
      const words = searchText.split(/\s+/).filter(w => w.length > 0);
      if (words.length >= 3) {
        const partial = words.slice(0, Math.max(3, Math.ceil(words.length * 0.5)));
        const pattern = partial.map(w => w.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('\\s+');
        const regex = new RegExp(pattern, 'i');
        const m = fullText.match(regex);
        if (m) { matchStart = m.index; matchLen = m[0].length; }
      }
    }

    if (matchStart === -1) return false;

    const matchEnd = matchStart + matchLen;

    // Build highlight rectangles from text item geometry (no text layer rendering)
    const highlightLayer = document.createElement('div');
    highlightLayer.className = 'pdf-highlight-layer';
    let firstRect = null;

    for (const { start, end, item } of itemMap) {
      if (start >= matchEnd || end <= matchStart) continue;

      // Compute screen position from item transform + viewport transform
      const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
      const fontHeight = Math.hypot(tx[2], tx[3]);
      const left = tx[4];
      const top = tx[5] - fontHeight;
      const width = item.width * viewport.scale;

      const rect = document.createElement('div');
      rect.className = 'pdf-highlight-rect';
      rect.style.left = left + 'px';
      rect.style.top = top + 'px';
      rect.style.width = width + 'px';
      rect.style.height = (fontHeight * 1.15) + 'px';
      highlightLayer.appendChild(rect);
      if (!firstRect) firstRect = rect;
    }

    if (!firstRect) return false;

    wrapper.appendChild(highlightLayer);

    // Scroll precisely to the highlighted text
    setTimeout(() => {
      const container = $('#pdfViewerContainer');
      const rr = firstRect.getBoundingClientRect();
      const cr = container.getBoundingClientRect();
      container.scrollTo({
        top: container.scrollTop + rr.top - cr.top - cr.height / 3,
        behavior: 'smooth',
      });
    }, 100);

    // Auto-fade highlights after delay
    setTimeout(() => {
      highlightLayer.style.transition = 'opacity 1.5s ease-out';
      highlightLayer.style.opacity = '0';
      setTimeout(() => highlightLayer.remove(), 2000);
    }, 5000);

    return true;
  } catch (e) {
    console.error('Text highlight error:', e);
    return false;
  }
}

async function openPdfPanel() {
  const panel = $('#pdfPanel');
  panel.style.display = 'flex';
  panel.offsetHeight;
  switchPanelTab('pdf');

  if (pdfState.paperId !== currentPaperId) {
    await loadPdfDocument(currentPaperId);
  }
}

function closeRightPanel() {
  $('#pdfPanel').style.display = 'none';
}

function switchPanelTab(tab) {
  const pdfContainer = $('#pdfViewerContainer');
  const discView = $('#discussionView');
  const tabPdf = $('#tabPdf');
  const tabDisc = $('#tabDiscussion');

  if (tab === 'pdf') {
    pdfContainer.style.display = 'flex';
    discView.classList.remove('active');
    tabPdf.classList.add('active');
    tabDisc.classList.remove('active');
  } else {
    pdfContainer.style.display = 'none';
    discView.classList.add('active');
    tabPdf.classList.remove('active');
    tabDisc.classList.add('active');
  }
}

// --- Discussion / Review ---

function createDiscussionMsg(role, round) {
  const div = document.createElement('div');
  div.className = `discussion-msg ${role}`;
  const label = document.createElement('div');
  label.className = 'msg-label';
  label.textContent = role === 'reader' ? `Q${round}` : `A${round}`;
  const body = document.createElement('div');
  body.className = 'msg-body';
  div.appendChild(label);
  div.appendChild(body);
  return div;
}

function renderDiscussionMsgBody(bodyEl) {
  // Always use dataset.raw as the source of truth
  const raw = bodyEl.dataset.raw;
  if (!raw) return;

  // Extract citations before markdown parse
  const cites = [];
  let md = raw.replace(
    /\[\[p\.(\d+)(?::(\d+))?\s*(?:"([^"]*)")?\s*\]\]/g,
    (match, page, yPos, quote) => {
      cites.push({ page, yPos: yPos || null, quote: quote || '' });
      return `%%CITE${cites.length - 1}%%`;
    }
  );

  // Extract LaTeX blocks before markdown parse
  const mathBlocks = [];
  // Block math $$...$$
  md = md.replace(/\$\$([\s\S]*?)\$\$/g, (m, tex) => {
    mathBlocks.push({ tex, display: true });
    return `%%MATH${mathBlocks.length - 1}%%`;
  });
  // Inline math $...$
  md = md.replace(/\$([^\$\n]+?)\$/g, (m, tex) => {
    mathBlocks.push({ tex, display: false });
    return `%%MATH${mathBlocks.length - 1}%%`;
  });

  let html = marked.parse(md);

  // Restore citations
  html = html.replace(/%%CITE(\d+)%%/g, (m, idx) => {
    const c = cites[parseInt(idx)];
    if (!c) return m;
    const yAttr = c.yPos ? ` data-y="${c.yPos}"` : '';
    const qSafe = c.quote.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;');
    const quoteAttr = c.quote ? ` data-quote="${qSafe}"` : '';
    return `<span class="citation" data-page="${c.page}"${yAttr}${quoteAttr}>[p.${c.page}]</span>`;
  });

  // Restore math blocks with KaTeX
  html = html.replace(/%%MATH(\d+)%%/g, (m, idx) => {
    const mb = mathBlocks[parseInt(idx)];
    if (!mb) return m;
    try {
      return katex.renderToString(mb.tex, { displayMode: mb.display, throwOnError: false });
    } catch {
      return mb.display ? `$$${mb.tex}$$` : `$${mb.tex}$`;
    }
  });

  bodyEl.innerHTML = html;
  bodyEl.classList.add('rendered');
}

async function loadSavedDiscussion(paperId) {
  try {
    const res = await fetch(`${API}/papers/${paperId}/discussion`);
    const data = await res.json();
    if (data.messages && data.messages.length > 0) {
      renderSavedDiscussion(data.messages);
    } else {
      $('#discussionView').innerHTML = '<div class="discussion-empty">No discussion yet.</div>';
    }
  } catch (e) {
    console.error('Failed to load discussion:', e);
  }
}

function renderSavedDiscussion(messages) {
  const discView = $('#discussionView');
  discView.innerHTML = '';
  let lastRound = 0;

  for (const msg of messages) {
    if (msg.round !== lastRound) {
      lastRound = msg.round;
      const divider = document.createElement('div');
      divider.className = 'discussion-round-divider';
      divider.textContent = `Round ${msg.round}`;
      discView.appendChild(divider);
    }
    const el = createDiscussionMsg(msg.role, msg.round);
    const body = el.querySelector('.msg-body');
    body.dataset.raw = msg.content;
    renderDiscussionMsgBody(body);
    discView.appendChild(el);
  }
}

// --- Utilities ---
function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function formatDate(dateStr) {
  if (!dateStr) return '';
  const d = new Date(dateStr + 'Z');
  return d.toLocaleDateString('zh-CN', { month: 'short', day: 'numeric', year: 'numeric' });
}

function showToast(msg, isError = false) {
  const t = document.createElement('div');
  t.className = 'toast' + (isError ? ' error' : '');
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 3500);
}

// Init
mermaid.initialize({
  startOnLoad: false,
  securityLevel: 'loose',
  theme: 'base',
  themeVariables: {
    primaryColor: '#e0f2fe',
    primaryTextColor: '#1e293b',
    primaryBorderColor: '#7dd3fc',
    secondaryColor: '#fef3c7',
    secondaryTextColor: '#1e293b',
    secondaryBorderColor: '#fcd34d',
    tertiaryColor: '#e0e7ff',
    tertiaryBorderColor: '#a5b4fc',
    lineColor: '#64748b',
    textColor: '#334155',
    fontSize: '14px',
    fontFamily: 'system-ui, -apple-system, "Noto Sans CJK SC", sans-serif',
    nodeTextColor: '#1e293b',
  },
  flowchart: { curve: 'basis', padding: 16, nodeSpacing: 50, rankSpacing: 60 },
});
loadPaperList();
</script>
</body>
</html>
